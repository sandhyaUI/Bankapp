"use strict";
var $__TypeError = TypeError,
    $__Object = Object,
    $__getOwnPropertyDescriptor = $__Object.getOwnPropertyDescriptor,
    $__getPrototypeOf = $__Object.getPrototypeOf,
    $__getPropertyDescriptor = function(object, name) {
      while (object !== null) {
        var result = $__getOwnPropertyDescriptor(object, name);
        if (result) return result;
        object = $__getPrototypeOf(object);
      }
      return undefined;
    },
    $__superDescriptor = function(proto, name) {
      if (!proto) throw new $__TypeError('super is null');
      return $__getPropertyDescriptor(proto, name);
    },
    $__superCall = function(self, proto, name, args) {
      var descriptor = $__superDescriptor(proto, name);
      if (descriptor) {
        if ('value'in descriptor) return descriptor.value.apply(self, args);
        if (descriptor.get) return descriptor.get.call(self).apply(self, args);
      }
      throw new $__TypeError("Object has no method '" + name + "'.");
    },
    $__getProtoParent = function(superClass) {
      if (typeof superClass === 'function') {
        var prototype = superClass.prototype;
        if (Object(prototype) === prototype || prototype === null) return superClass.prototype;
      }
      if (superClass === null) return null;
      throw new TypeError();
    },
    $__getOwnPropertyNames = $__Object.getOwnPropertyNames,
    $__getDescriptors = function(object) {
      var descriptors = {},
          name,
          names = $__getOwnPropertyNames(object);
      for (var i = 0; i < names.length; i++) {
        var name = names[i];
        descriptors[name] = $__getOwnPropertyDescriptor(object, name);
      }
      return descriptors;
    },
    $__createClass = function(object, staticObject, protoParent, superClass, hasConstructor) {
      var ctor = object.constructor;
      if (typeof superClass === 'function') ctor.__proto__ = superClass;
      if (!hasConstructor && protoParent === null) ctor = object.constructor = function() {};
      var descriptors = $__getDescriptors(object);
      descriptors.constructor.enumerable = false;
      ctor.prototype = Object.create(protoParent, descriptors);
      Object.defineProperties(ctor, $__getDescriptors(staticObject));
      return ctor;
    },
    $__toObject = function(value) {
      if (value == null) throw $__TypeError();
      return $__Object(value);
    },
    $__spread = function() {
      var rv = [],
          k = 0;
      for (var i = 0; i < arguments.length; i++) {
        var value = $__toObject(arguments[i]);
        for (var j = 0; j < value.length; j++) {
          rv[k++] = value[j];
        }
      }
      return rv;
    };
var GlobalsCompiler = require("es6-module-transpiler").GlobalsCompiler;
var SourceModifier = require("es6-module-transpiler").SourceModifier;
var dirname = require("path").dirname;
var resolve = require("path").resolve;
var LocalsCompiler = function($__super) {
  'use strict';
  var $__proto = $__getProtoParent($__super);
  var $LocalsCompiler = ($__createClass)({
    constructor: function() {
      for (var args = [],
          $__1 = 0; $__1 < arguments.length; $__1++) args[$__1] = arguments[$__1];
      $__superCall(this, $__proto, "constructor", $__spread(args));
      this.options.imports = this.options.imports || {};
    },
    stringify: function() {
      if (!this.moduleName) {
        throw new Error('moduleName must be defiend for locals compiler');
      }
      this.hasDefaultExport = this.exports.reduce(function(acc, item) {
        return acc || item.default;
      }, false);
      var string = this.string.toString();
      this.source = new SourceModifier(string);
      this.map = [];
      var out = this.buildPreamble(this.exports.length > 0);
      this.buildImports();
      this.buildExports();
      out += this.indentLines();
      if (this.exports.length > 0) {
        out += "\n  return __exports__;";
      }
      out += "\n})";
      out += this.buildSuffix();
      out += ";\n";
      return out;
    },
    buildPreamble: function() {
      var out = "",
          dependencyNames = this.dependencyNames;
      if (this.exports.length > 0) {
        out += ("var " + (this.options.imports[this.moduleName] || this.moduleName) + " = ");
      }
      out += "(function(";
      for (var idx = 0; idx < dependencyNames.length; idx++) {
        out += ("__dependency" + (idx + 1) + "__");
        this.map[dependencyNames[idx]] = idx + 1;
        if (!(idx === dependencyNames.length - 1)) out += ", ";
      }
      out += ") {\n";
      out += '  "use strict";\n';
      if (this.exports.length > 0) {
        out += "  var __exports__";
        if (!this.hasDefaultExport) {
          out += " = {}";
        }
        out += ";\n";
      }
      return out;
    },
    buildSuffix: function() {
      var dependencyNames = this.dependencyNames;
      var out = "(";
      for (var idx = 0; idx < dependencyNames.length; idx++) {
        var name = dependencyNames[idx];
        name = this.resolveModuleName(name);
        out += this.options.imports[name] || name;
        if (!(idx === dependencyNames.length - 1)) out += ", ";
      }
      out += ")";
      return out;
    },
    doModuleImport: function(name, dependencyName, idx) {
      return ("var " + name + " = __dependency" + this.map[dependencyName] + "__;\n");
    },
    doDefaultImport: function(name, dependencyName, idx) {
      return ("var " + name + " = __dependency" + this.map[dependencyName] + "__;\n");
    },
    doNamedImport: function(name, dependencyName, alias) {
      return ("var " + alias + " = __dependency" + this.map[dependencyName] + "__." + name + ";\n");
    },
    doDefaultExport: function(identifier) {
      return "__exports__ = ";
    },
    resolveModuleName: function(name) {
      if (/^\.{1,2}\//.test(name)) {
        name = resolve(dirname(this.moduleName), name);
        name = name.replace(/\.js$/, '') + '.js';
      }
      return name;
    }
  }, {}, $__proto, $__super, true);
  return $LocalsCompiler;
}(GlobalsCompiler);
exports["default"] = LocalsCompiler;

//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG1wL3RyYW5zcGlsZWQvbGliL2xvY2Fscy1jb21waWxlci5qcy5lczYiLCJzb3VyY2VzIjpbInRtcC90cmFuc3BpbGVkL2xpYi9sb2NhbHMtY29tcGlsZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsWUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0ksR0FBQSxnQkFBQSxFQUFrQixRQUFPLENBQUMsdUJBQUEsQ0FBQSxDQUFBLGVBQUE7QUFDMUIsR0FBQSxlQUFBLEVBQWlCLFFBQU8sQ0FBQyx1QkFBQSxDQUFBLENBQUEsY0FBQTtBQUN6QixHQUFBLFFBQUEsRUFBVSxRQUFPLENBQUMsTUFBQSxDQUFBLENBQUEsT0FBQTtBQUNsQixHQUFBLFFBQUEsRUFBVSxRQUFPLENBQUMsTUFBQSxDQUFBLENBQUEsT0FBQTtHQUVoQixlQUFBOzs7O0FBQ0osZUFBQSxDQUFBLFNBQUEsQ0FBWTs7OzREQUNELElBQUEsQ0FBQSxDQUFBO0FBRVQsVUFBQSxDQUFBLE9BQUEsQ0FBQSxPQUFBLEVBQXVCLEtBQUEsQ0FBQSxPQUFBLENBQUEsT0FBQSxHQUF3QixFQUFBLENBQUE7QUFBQSxLQUFBO0FBR2pELGFBQUEsQ0FBQSxTQUFBLENBQVUsQ0FBRTtBQUNWLFFBQUEsRUFBSSxDQUFDLElBQUEsQ0FBQSxVQUFBLENBQWlCO0FBQ3BCLGFBQU0sSUFBSSxNQUFLLENBQUMsZ0RBQUEsQ0FBQTtBQUFBO0FBR2xCLFVBQUEsQ0FBQSxnQkFBQSxFQUF3QixLQUFBLENBQUEsT0FBQSxDQUFBLE1BQW1CLENBQUMsUUFBQSxDQUFTLEdBQUEsQ0FBSyxLQUFBLENBQU07QUFDOUQsY0FBTyxJQUFBLEdBQU8sS0FBQSxDQUFBLE9BQUE7QUFBQSxPQUFBLENBQ2IsTUFBQSxDQUFBO0FBRUMsU0FBQSxPQUFBLEVBQVMsS0FBQSxDQUFBLE1BQUEsQ0FBQSxRQUFvQixDQUFBLENBQUE7QUFDakMs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aWxlciA9IHJlcXVpcmUoXCJlczYtbW9kdWxlLXRyYW5zcGlsZXJcIikuR2xvYmFsc0NvbXBpbGVyO1xudmFyIFNvdXJjZU1vZGlmaWVyID0gcmVxdWlyZShcImVzNi1tb2R1bGUtdHJhbnNwaWxlclwiKS5Tb3VyY2VNb2RpZmllcjtcbnZhciBkaXJuYW1lID0gcmVxdWlyZShcInBhdGhcIikuZGlybmFtZTtcbnZhciByZXNvbHZlID0gcmVxdWlyZShcInBhdGhcIikucmVzb2x2ZTtcblxuY2xhc3MgTG9jYWxzQ29tcGlsZXIgZXh0ZW5kcyBHbG9iYWxzQ29tcGlsZXIge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICB0aGlzLm9wdGlvbnMuaW1wb3J0cyA9IHRoaXMub3B0aW9ucy5pbXBvcnRzIHx8IHt9O1xuICB9XG5cbiAgc3RyaW5naWZ5KCkge1xuICAgIGlmICghdGhpcy5tb2R1bGVOYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vZHVsZU5hbWUgbXVzdCBiZSBkZWZpZW5kIGZvciBsb2NhbHMgY29tcGlsZXInKTtcbiAgICB9XG5cbiAgICB0aGlzLmhhc0RlZmF1bHRFeHBvcnQgPSB0aGlzLmV4cG9ydHMucmVkdWNlKGZ1bmN0aW9uKGFjYywgaXRlbSkge1xuICAgICAgcmV0dXJuIGFjYyB8fCBpdGVtLmRlZmF1bHQ7XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgdmFyIHN0cmluZyA9IHRoaXMuc3RyaW5nLnRvU3RyaW5nKCk7ICAvLyBzdHJpbmcgaXMgYWN0dWFsbHkgYSBub2RlIGJ1ZmZlclxuICAgIHRoaXMuc291cmNlID0gbmV3IFNvdXJjZU1vZGlmaWVyKHN0cmluZyk7XG5cbiAgICB0aGlzLm1hcCA9IFtdO1xuICAgIHZhciBvdXQgPSB0aGlzLmJ1aWxkUHJlYW1ibGUodGhpcy5leHBvcnRzLmxlbmd0aCA+IDApO1xuXG4gICAgdGhpcy5idWlsZEltcG9ydHMoKTtcbiAgICB0aGlzLmJ1aWxkRXhwb3J0cygpO1xuXG4gICAgb3V0ICs9IHRoaXMuaW5kZW50TGluZXMoKTtcbiAgICBpZiAodGhpcy5leHBvcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIG91dCArPSBcIlxcbiAgcmV0dXJuIF9fZXhwb3J0c19fO1wiO1xuICAgIH1cbiAgICBvdXQgKz0gXCJcXG59KVwiO1xuICAgIG91dCArPSB0aGlzLmJ1aWxkU3VmZml4KCk7XG4gICAgb3V0ICs9IFwiO1xcblwiO1xuXG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIGJ1aWxkUHJlYW1ibGUoKSB7XG4gICAgdmFyIG91dCA9IFwiXCIsXG4gICAgICAgIGRlcGVuZGVuY3lOYW1lcyA9IHRoaXMuZGVwZW5kZW5jeU5hbWVzO1xuXG4gICAgaWYgKHRoaXMuZXhwb3J0cy5sZW5ndGggPiAwKSB7XG4gICAgICBvdXQgKz0gYHZhciAke3RoaXMub3B0aW9ucy5pbXBvcnRzW3RoaXMubW9kdWxlTmFtZV0gfHwgdGhpcy5tb2R1bGVOYW1lfSA9IGA7XG4gICAgfVxuXG4gICAgb3V0ICs9IFwiKGZ1bmN0aW9uKFwiO1xuXG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgZGVwZW5kZW5jeU5hbWVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgIG91dCArPSBgX19kZXBlbmRlbmN5JHtpZHgrMX1fX2A7XG4gICAgICB0aGlzLm1hcFtkZXBlbmRlbmN5TmFtZXNbaWR4XV0gPSBpZHgrMTtcbiAgICAgIGlmICghKGlkeCA9PT0gZGVwZW5kZW5jeU5hbWVzLmxlbmd0aCAtIDEpKSBvdXQgKz0gXCIsIFwiO1xuICAgIH1cblxuICAgIG91dCArPSBcIikge1xcblwiO1xuXG4gICAgb3V0ICs9ICcgIFwidXNlIHN0cmljdFwiO1xcbic7XG5cbiAgICBpZiAodGhpcy5leHBvcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIG91dCArPSBcIiAgdmFyIF9fZXhwb3J0c19fXCI7XG4gICAgICBpZiAoIXRoaXMuaGFzRGVmYXVsdEV4cG9ydCkge1xuICAgICAgICBvdXQgKz0gXCIgPSB7fVwiO1xuICAgICAgfVxuICAgICAgb3V0ICs9IFwiO1xcblwiO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICBidWlsZFN1ZmZpeCgpIHtcbiAgICB2YXIgZGVwZW5kZW5jeU5hbWVzID0gdGhpcy5kZXBlbmRlbmN5TmFtZXM7XG4gICAgdmFyIG91dCA9IFwiKFwiO1xuXG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgZGVwZW5kZW5jeU5hbWVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgIHZhciBuYW1lID0gZGVwZW5kZW5jeU5hbWVzW2lkeF07XG4gICAgICBuYW1lID0gdGhpcy5yZXNvbHZlTW9kdWxlTmFtZShuYW1lKTtcblxuICAgICAgb3V0ICs9IHRoaXMub3B0aW9ucy5pbXBvcnRzW25hbWVdIHx8IG5hbWU7XG4gICAgICBpZiAoIShpZHggPT09IGRlcGVuZGVuY3lOYW1lcy5sZW5ndGggLSAxKSkgb3V0ICs9IFwiLCBcIjtcbiAgICB9XG5cbiAgICBvdXQgKz0gXCIpXCI7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIGRvTW9kdWxlSW1wb3J0KG5hbWUsIGRlcGVuZGVuY3lOYW1lLCBpZHgpIHtcbiAgICByZXR1cm4gYHZhciAke25hbWV9ID0gX19kZXBlbmRlbmN5JHt0aGlzLm1hcFtkZXBlbmRlbmN5TmFtZV19X187XFxuYDtcbiAgfVxuXG4gIGRvRGVmYXVsdEltcG9ydChuYW1lLCBkZXBlbmRlbmN5TmFtZSwgaWR4KSB7XG4gICAgcmV0dXJuIGB2YXIgJHtuYW1lfSA9IF9fZGVwZW5kZW5jeSR7dGhpcy5tYXBbZGVwZW5kZW5jeU5hbWVdfV9fO1xcbmA7XG4gIH1cblxuICBkb05hbWVkSW1wb3J0KG5hbWUsIGRlcGVuZGVuY3lOYW1lLCBhbGlhcykge1xuICAgIHJldHVybiBgdmFyICR7YWxpYXN9ID0gX19kZXBlbmRlbmN5JHt0aGlzLm1hcFtkZXBlbmRlbmN5TmFtZV19X18uJHtuYW1lfTtcXG5gO1xuICB9XG5cbiAgZG9EZWZhdWx0RXhwb3J0KGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gYF9fZXhwb3J0c19fID0gYDtcbiAgfVxuXG4gIHJlc29sdmVNb2R1bGVOYW1lKG5hbWUpIHtcbiAgICBpZiAoL15cXC57MSwyfVxcLy8udGVzdChuYW1lKSkge1xuICAgICAgbmFtZSA9IHJlc29sdmUoZGlybmFtZSh0aGlzLm1vZHVsZU5hbWUpLCBuYW1lKTtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1xcLmpzJC8sICcnKSArICcuanMnO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbiAgfVxufVxuXG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IExvY2Fsc0NvbXBpbGVyOyJdfQ==